{
    "contents" : "\ncatalog <- function(data, time.begin=NULL, study.start=NULL,\n                    study.end=NULL, study.length=NULL,\n                    lat.range=NULL, long.range=NULL,\n                    region.poly=NULL, mag.threshold=NULL,\n                    flatmap=TRUE, tz=\"GMT\")\n{\n  data <- as.data.frame(data)\n  dnames <- tolower(names(data))\n  names(data) <- dnames\n  vnames <- c(\"date\", \"time\", \"long\", \"lat\", \"mag\")\n  if (!all(vnames %in% dnames))\n    stop(paste(\"argument\", sQuote(data),\n               \"must be a data frame with column names \",\n               toString(sQuote(vnames))))\n  if (any(is.na(data[, vnames])))\n    stop(paste(sQuote(vnames), \"must not contain NA values\"))\n  if (!is.numeric(data$lat) || !is.numeric(data$long) || !is.numeric(data$mag))\n    stop(\"lat, long and mag columns must be numeric vectors\")\n\n  # extract spatial coordinates and magnitude\n  xx <- data$long  # longitude of epicenter: coordinates\n  yy <- data$lat   # latitude of epicenter : coordinates\n  mm <- data$mag   # magnitude\n\n  # extract date and time of events\n  dt <- as.POSIXlt(paste(data$date, data$time), tz=tz)\n  if (any(duplicated(dt)))\n    stop(paste(\"no more than one event can occur simultaneously!\",\n               \"check events\", toString(which(duplicated(dt)))))\n  if (is.unsorted(dt))\n  {\n    warning(paste(\"events were not chronologically sorted:\",\n                  \"they have been sorted in ascending order\"))\n    data <- data[order(dt), ]\n    dt <- sort(dt)\n  }\n\n  if (is.null(time.begin))\n    time.begin <- min(dt)\n  else\n  {\n    time.begin <- as.POSIXlt(time.begin, tz=tz)\n    if (all(dt < time.begin))\n      stop(paste(\"change time.begin: no event has occurred after:\",\n                 sQuote(time.begin)))\n  }\n  if (is.null(study.start))\n    study.start <- time.begin\n  else\n  {\n    study.start <- as.POSIXlt(study.start, tz=tz)\n    if (study.start < time.begin)\n      stop(paste(\"study.start\", sQuote(study.start),\n                 \"can not be set before time.begin =\", sQuote(time.begin)))\n  }\n  if (!is.null(study.length))\n  {\n    if (!is.null(study.end))\n      stop(\"eihter study.end or study.length needs to be specified, not both\")\n    else\n    {\n      if(!is.numeric(study.length) || length(study.length) > 1)\n        stop(paste(\"study.length must be single numeric value: in deciaml days\"))\n      study.end <- study.start + study.length * 24 * 60 * 60\n    }\n  }\n  if (is.null(study.end))\n    study.end <- max(dt)\n  else\n  {\n    study.end <- as.POSIXlt(study.end, tz=tz)\n    if (study.end < study.start)\n      stop(paste(\"study.end\", sQuote(study.end),\n                 \"can not be set before study.start\", sQuote(study.start)))\n  }\n  tt <- date2day(dt, time.begin, tz=tz)\n\n  # spatial region\n  if (is.null(lat.range))\n    lat.range <- range(yy)\n  else if (!is.vector(lat.range) || length(lat.range) != 2 || lat.range[2] <= lat.range[1])\n    stop(\"lat.range must be a vector of length 2 giving (lat.min, lat.max)\")\n  if (is.null(long.range))\n    long.range <- range(xx)\n  else if (!is.vector(long.range) || length(long.range) != 2 || long.range[2] <= long.range[1])\n    stop(\"long.range must be a vector of length 2 giving (long.min, long.max)\")\n\n  if (is.null(region.poly))\n  {\n    region.poly <- list(long=c(long.range, rev(long.range)),\n                        lat=rep(lat.range, each=2))\n    region.win <- spatstat::owin(xrange=long.range, yrange=lat.range)\n  }\n  else\n  {\n    if (is.data.frame(region.poly))\n      region.poly <- as.list(region.poly)\n    if (!is.list(region.poly) || !all(c(\"lat\", \"long\") %in% names(region.poly)))\n      stop(\"region.poly must be a list with components lat and long\")\n    if (any(is.na(region.poly$lat)) || any(is.na(region.poly$long)))\n      stop(\"lat and long coordinates must not contain NA values\")\n    if (!is.numeric(region.poly$lat) || !is.numeric(region.poly$long) ||\n        length(region.poly$lat) != length(region.poly$long))\n      stop(\"lat and long coordinates must be numeric vectors of equal length\")\n    if (length(region.poly$lat) < 3)\n      stop(\"region.poly needs at least 3 vertices\")\n    region.win <- spatstat::owin(poly=list(x=region.poly$long, y=region.poly$lat))\n    region.area <- spatstat::area.owin(region.win) #Area.xypolygon(list(x=region.poly$long, y=region.poly$lat))\n    if (region.area < 0)\n      stop(paste(\"Area of polygon is negative -\",\n                 \"maybe traversed in wrong direction?\"))\n  }\n\n  # magnitude threshold\n  if (is.null(mag.threshold))\n    mag.threshold <- min(data$mag)\n  else if (!is.numeric(mag.threshold) || length(mag.threshold) > 1)\n    stop(\"mag.threshold must be a single numeric value\")\n\n  # project long-lat coordinates to flat map coordinates\n  longlat.coord <- data.frame(long=xx, lat=yy)\n  if (flatmap)\n  {\n    ymean <- spatstat::centroid.owin(region.win)$y\n    theta <- cos(ymean * pi / 180)\n    A <- matrix(c(theta, 0, 0, 1), ncol=2, nrow=2)\n    region.win <- spatstat::affine(region.win, mat=A, vec=c(0, 0), rescue=TRUE)\n    xx <- theta * xx\n  }\n\n  ok <- (dt <= study.end) & (dt > time.begin) & (mm >= mag.threshold)\n  xx <- xx[ok]\n  yy <- yy[ok]\n  tt <- tt[ok]\n  mm <- mm[ok] - mag.threshold\n  flag <- as.integer(spatstat::inside.owin(xx, yy, region.win))\n  flag[dt[ok] < study.start] <- -2\n  revents <- cbind(tt, xx, yy, mm, flag, 0, 1, 0)\n  longlat.coord <- longlat.coord[ok, ]\n  longlat.coord$flag <- flag\n  longlat.coord$dt <- dt[ok]\n  X <- spatstat::ppx(data.frame(t=tt, x=xx, y=yy, m=mm),\n           coord.type=c(\"t\", \"s\", \"s\", \"m\"))\n\n  switch(region.win$type, polygonal= {\n    px <- region.win$bdry[[1]]$x\n    py <- region.win$bdry[[1]]$y\n  }, rectangle = {\n    px <- c(region.win$xrange, rev(region.win$xrange))\n    py <- rep(region.win$yrange, each=2)\n  })\n  # repeat the first vertex\n  np <- length(px) + 1\n  px[np] <- px[1]\n  py[np] <- py[1]\n  rpoly <- cbind(px, py)\n\n  rtperiod <- c(date2day(study.start, time.begin, tz=tz),\n                date2day(study.end, time.begin, tz=tz))\n  out <- list(revents=revents, rpoly=rpoly, rtperiod=rtperiod, X=X,\n              region.poly=region.poly, region.win=region.win,\n              time.begin=time.begin, study.start=study.start,\n              study.end=study.end, study.length=study.length,\n              mag.threshold=mag.threshold, longlat.coord=longlat.coord)\n  class(out) <- \"catalog\"\n  return(out)\n}\n\n\nprint.catalog <- function (x, ...)\n{\n  cat(\"earthquake catalog:\\n  time begin\", as.character(x$time.begin),\n      \"\\n  study period:\", as.character(x$study.start),\n      \" to \", as.character(x$study.end), \"(\", x$rtperiod[2], \"days)\")\n  cat(\"\\ngeographical region:\\n  \")\n  switch(x$region.win$type, rectangle={\n    cat(\"  rextangular = [\", x$region.poly$long[1], \",\", x$region.poly$long[2],\n        \"] x [\", x$region.poly$lat[1], x$region.poly$lat[2], \"]\\n\")\n  }, polygonal={\n    cat(\"  polygonal with vertices:\\n\")\n    print(cbind(lat=x$region.poly$lat, long=x$region.poly$long))\n  })\n  cat(\"threshold magnitude:\", x$mag.threshold)\n  cat(\"\\nnumber of events:\\n  total events\", nrow(x$revents),\n      \":\", sum(x$revents[, 5] == 1), \"target events, \",\n      sum(x$revents[, 5] != 1), \"complementary events\\n  (\",\n      sum(x$revents[, 5] == 0), \"events outside geographical region,\",\n      sum(x$revents[, 5] == -2), \"events outside study period)\")\n}\n\nplot.catalog <- function(x, ...)\n{\n  oldpar <- par(no.readonly = TRUE)\n  par(mfrow=c(2, 2), mar=c(4, 4.1, 1, 1))\n  plot(x$longlat.coord$long, x$longlat.coord$lat, xlab=\"long\", ylab=\"lat\", col=8,\n       cex=2 * (x$revents[, 4] + 0.1)/max(x$revents[, 4]), asp=TRUE)\n  ok <- x$revents[, 5] == 1\n  points(x$longlat.coord$long[ok], x$longlat.coord$lat[ok], col=4,\n         cex=2 * (x$revents[ok, 4] + 0.1)/max(x$revents[ok, 4]))\n  polygon(x$region.poly$long, x$region.poly$lat, border=2)\n  mbk <- seq(0, max(x$revents[, 4]), 0.1) + x$mag.threshold\n  mct <- cut(x$revents[, 4] + x$mag.threshold, mbk)\n  plot(mbk[-length(mbk)], as.numeric(table(mct)), type=\"b\",\n       xlab=\"mag\", ylab=\"number of events\", axes=FALSE)\n  axis(1); axis(2)\n  tbk <- seq(0, max(x$revents[, 1]), l=100)\n  tct <- cut(x$revents[, 1], tbk)\n  plot(tbk[-length(tbk)], cumsum(table(tct)), type=\"l\",\n       xlab=\"time\", ylab=\"number of events\", axes=FALSE)\n  axis(1); axis(2)\n  abline(v=x$rtperiod[1], col=2, lty=2)\n  abline(v=x$rtperiod[2], col=2, lty=2)\n  plot(x$revents[, 1], x$revents[, 3], xlab=\"time\", ylab=\"lat\",\n       cex=2 * (x$revents[, 4] + 0.1)/max(x$revents[, 4]), col=8)\n  points(x$revents[ok, 1], x$revents[ok, 3], col=4,\n         cex=2 * (x$revents[ok, 4] + 0.1)/max(x$revents[ok, 4]))\n  par(oldpar)\n}\n",
    "created" : 1451979081950.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3348505625",
    "id" : "E85F569E",
    "lastKnownWriteTime" : 1452076018,
    "path" : "~/Dropbox/RCodes/RpkgETAS/ETAS/R/catalog.R",
    "project_path" : "R/catalog.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}